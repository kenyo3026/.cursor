---
alwaysApply: true
description: Incremental development approach for code generation
---

# Incremental Development Approach

## Core Principle

When generating new code, modules, or features, **start with core functionality first, then gradually expand**.

## Implementation Strategy

### 1. **Start Simple**
- Implement the minimal viable version that works
- Focus on the primary use case
- Avoid over-engineering in the initial implementation

### 2. **Build Incrementally**
- Add complexity only when needed
- Extend functionality in logical steps
- Each iteration should be functional and testable

### 3. **Expand Gradually**
- Add edge case handling after core works
- Introduce advanced features as follow-up enhancements
- Consider performance optimizations in later iterations

### 4. **Environment Setup**
Before executing commands for the first time in a session, **verify the current environment**:

#### **Python Projects**
- **Check for uv**: Look for `.uv` folder in workspace → try `uv run`
- **Check for conda**: Look for `environment.yml` or `conda` → try `conda activate`
- **Check for venv**: Look for `venv/` or `env/` folders → activate virtual environment
- **Fallback**: Use system Python if no environment detected

#### **Other Languages**
- **Node.js/TypeScript**: Check for `package.json` → use `npm` or `yarn`
- **Go**: Check for `go.mod` → use `go` commands
- **Rust**: Check for `Cargo.toml` → use `cargo` commands

#### **When Environment Setup Fails**
If activation fails or environment is unclear:
1. **Ask the user** about the preferred environment
2. **Request environment name** (e.g., conda environment name)
3. **Confirm setup** before proceeding with commands

#### **Session Memory**
- **Remember environment** once established in the current session
- **Skip re-verification** for subsequent commands in the same conversation
- **Re-check only** when switching projects or starting a new session

## Examples

**❌ Avoid**: Creating a comprehensive solution with all features at once
**✅ Prefer**:
1. First iteration: Basic functionality that works
2. Second iteration: Add error handling
3. Third iteration: Add configuration options
4. Fourth iteration: Add advanced features

This approach ensures working code at every step and allows for iterative feedback and refinement.
